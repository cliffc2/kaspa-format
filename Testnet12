Kaspa Testnet 12 (TN12) Covenant Examples
The Silverscript repository contains all the TN12 covenant implementations. Here are the key example contracts:
kaspanet / silverscript / silverscript-lang / tests / examples_tests.rs

1. Simple Covenant Example (SilverScript)

pragma silverscript ^0.1.0;

contract SimpleCovenant(pubkey recipient) {
    entrypoint function spend() {
        // First output must go to the recipient
        bytes34 recipientLock = new LockingBytecodeP2PK(recipient);
        require(tx.outputs[0].lockingBytecode == recipientLock);
    }
}


2. Recurring Payment Covenant

pragma silverscript ^0.1.0;

contract RecurringPayment(pubkey recipient, int paymentAmount, int period) {
    entrypoint function withdraw() {
        // Must wait for the period to elapse
        require(this.age >= period);
        
        // First output must pay the recipient
        bytes34 recipientLock = new LockingBytecodeP2PK(recipient);
        require(tx.outputs[0].lockingBytecode == recipientLock);
        require(tx.outputs[0].value >= paymentAmount);
        
        // Calculate change
        int inputValue = tx.inputs[this.activeInputIndex].value;
        // ... remaining logic
    }
}


3. Covenant Escrow Example (Rust Test)

fn compiles_covenant_escrow_example_and_verifies() {
    let source = load_example_source("covenant_escrow.sil");

    let arbiter = random_keypair();
    let arbiter_pk = arbiter.x_only_public_key().0.serialize();
    let arbiter_hash =
        blake2b_simd::Params::new().hash_length(32).to_state().update(arbiter_pk.as_slice()).finalize().as_bytes().to_vec();
    let buyer = [10u8; 32];
    let seller = [11u8; 32];
    let constructor_args = vec![arbiter_hash.clone().into(), buyer.to_vec().into(), seller.to_vec().into()];

    let compiled = compile_contract(&source, &constructor_args, CompileOptions::default()).expect("compile succeeds");

    let input_value = 12_000u64;
    let output0_value = input_value - 1000;
    let output0_script = build_p2pk_script(&buyer);

    // Calculate schnorr signature
    let sig_hash = calc_schnorr_signature_hash(&tx.as_verifiable(), 0, SIG_HASH_ALL, &reused_values);
    let msg = secp256k1::Message::from_digest_slice(sig_hash.as_bytes().as_slice()).unwrap();
    let sig = arbiter.sign_schnorr(msg);
    let mut signature = Vec::new();
    signature.extend_from_slice(sig.as_ref().as_slice());
    signature.push(SIG_HASH_ALL.to_u8());

    // Test spend() function call (build sigscript for spend()).
    let sigscript =
        compiled.build_sig_script("spend", vec![arbiter_pk.to_vec().into(), signature.clone().into()]).expect("sigscript builds");
    tx.tx.inputs[0].signature_script = sigscript;

4. Covenant Mecenas Example (Recurring Payments)

#[test]
fn compiles_covenant_mecenas_example_and_verifies() {
    let source = load_example_source("covenant_mecenas.sil");

    let recipient = [21u8; 32];
    let funder_key = random_keypair();
    let funder_pk = funder_key.x_only_public_key().0.serialize();
    let funder_hash =
        blake2b_simd::Params::new().hash_length(32).to_state().update(funder_pk.as_slice()).finalize().as_bytes().to_vec();
    let pledge = 2_000i64;
    let period = 10i64;
    let constructor_args = vec![recipient.to_vec().into(), funder_hash.clone().into(), pledge.into(), period.into()];

    let compiled = compile_contract(&source, &constructor_args, CompileOptions::default()).expect("compile succeeds");

    // Test receive() with changeValue > pledge + minerFee (else branch).
    let sigscript = compiled.build_sig_script("receive", vec![]).expect("sigscript builds");
    
    let input_value = 10000u64;
    let output0_value = pledge as u64;
    let output1_value = input_value - pledge as u64 - 1000;
    let output0_script = build_p2pk_script(&recipient);

    let result = run_contract_with_tx_sequence(
        compiled.script.clone(),
        output0_script,
        compiled.script.clone(),
        input_value,
        output0_value,
        output1_value,
        sigscript,
        0,
        period as u64,
    );
    assert!(result.is_ok(), "covenant mecenas example failed: {}", result.unwrap_err());
}


5. Covenant Last Will Example (Time-locked Inheritance)

#[test]
fn compiles_covenant_last_will_and_verifies() {
    let output = TransactionOutput {
        value: 4_000,
        script_public_key: ScriptPublicKey::new(0, compiled.script.clone().into()),
        covenant: None,
    };

    let tx = Transaction::new(1, vec![input.clone()], vec![output.clone()], 0, Default::default(), 0, vec![]);
    let utxo_entry = UtxoEntry::new(output.value, ScriptPublicKey::new(0, compiled.script.clone().into()), 0, tx.is_coinbase(), None);
    let mut tx = MutableTransaction::with_entries(tx, vec![utxo_entry.clone()]);

    let reused_values = SigHashReusedValuesUnsync::new();
    let sig_hash = calc_schnorr_signature_hash(&tx.as_verifiable(), 0, SIG_HASH_ALL, &reused_values);
    let msg = secp256k1::Message::from_digest_slice(sig_hash.as_bytes().as_slice()).unwrap();
    let sig = recipient_key.sign_schnorr(msg);
    
    // ...execute and verify
    let flags = EngineFlags { covenants_enabled: true };
}

6. Covenant Opcode Introspection (Rust)

#[test]
fn executes_opcode_builtins_covenants() {
    let source = r#"
        contract Test() {
            entrypoint function main() {
                require(OpAuthOutputCount(0) == 2);
                require(OpAuthOutputIdx(0, 1) == 2);
                require(OpInputCovenantId(0) == bytes("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"));
                require(OpCovInputCount(bytes("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")) == 2);
                require(OpCovInputIdx(bytes("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"), 1) == 2);
                require(OpCovOutCount(bytes("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")) == 2);
                require(OpCovOutputIdx(bytes("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"), 1) == 2);
            }
        }
    "#;

    let compiled = compile_contract(source, &[], CompileOptions::default()).expect("compile succeeds");
    let selector = selector_for(&compiled, "main");
    // ...
}

7. Transaction Building & Covenant Binding (Rust SDK)

#[test]
fn test_state_transition_with_spk_verification() {
    let mut tx_output = TransactionOutput::new(SOMPI_PER_KASPA, output_spk);
    tx_output.covenant = Some(CovenantBinding { authorizing_input: 0, covenant_id });

    let mut tx =
        Transaction::new(TX_VERSION, vec![tx_input], vec![tx_output.clone(), tx_output], 0, SUBNETWORK_ID_NATIVE, 0, vec![]);

    // Build scriptSig: <action_data> <input_redeem_script>
    let sig_script = TxScriptBuilder::new()
        .add_data(&action_data)?
        .add_data(&input_redeem_script)?
        .drain();

    let utxo_entry = UtxoEntry::new(SOMPI_PER_KASPA, input_spk, 0, false, Some(covenant_id));
    let sig_cache = Cache::new(10_000);
    let reused_values = SigHashReusedValuesUnsync::new();
    let flags = EngineFlags { covenants_enabled: true };

    let populated_tx = PopulatedTransaction::new(&tx, vec![utxo_entry.clone()]);
    let covenants_ctx = CovenantsContext::from_tx(&populated_tx).expect("covenants context");
    let ctx = EngineCtx::new(&sig_cache).with_reused(&reused_values).with_covenants_ctx(&covenants_ctx);
    let mut engine = TxScriptEngine::from_transaction_input(&populated_tx, &tx.inputs[0], 0, &utxo_entry, ctx, flags);
}

Resources

Repository: https://github.com/kaspanet/silverscript
Tutorial: https://github.com/kaspanet/silverscript/blob/main/TUTORIAL.md
Example Contracts: https://github.com/kaspanet/silverscript/tree/main/silverscript-lang/tests/examples/
Test Suite: https://github.com/kaspanet/silverscript/tree/main/silverscript-lang/tests
Key TN12 Covenant Features
The examples demonstrate:

Covenant binding to specific outputs
Introspection opcodes (OpAuthOutputCount, OpInputCovenantId, OpCovInputCount, etc.)
Signature verification with Schnorr signatures
State transitions and transaction validation
Recurring payments and time-locked conditions
These are the official working examples for Kaspa Testnet 12 covenant development!
